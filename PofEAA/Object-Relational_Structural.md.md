# オブジェクトリレーション構造パターン

## 一意フィールド
これは単に、primary key を フィールドにしようという話。
- 意味のあるカラムを primary key として使うか、連番のような代理キーを primary key として使うか
- 複数カラムからなる primary key の場合、 Key オブジェクトを作っておくと汎用かできるぜ
的なことがメインで書いてある

## マッピング
テーブル間の1対多、多対多の関係をオブジェクトでどのように表現するかという話

### 1対多の場合
外部キーマッピングと依存マッピングから選択する

親オブジェクトは、子オブジェクトをコレクションで保持することになるが、そのコレクションの更新をDBに反映する部分が複雑となる。
(12.2.1節で議論されている)
方法としては以下の3通りから選択する。
(1) 削除と挿入
まずDBのデータを全て削除し、その後コレクション内のデータを全て挿入する 
→ 依存マッピングの場合に可能
(2) バックポインタの追加
外部キーマッピングを利用し、子オブジェクト側で参照を更新する
(3) コレクションの差分表示
DB内の関連とオブジェクトが持つコレクションを比較し、DBだけにあるやつはDBから削除し、コレクションだけにあるやつはDBに追加する


- 外部キーマッピング
  - RDB内の表現と同じく、子のフィールドに親のオブジェクトを持つという構成。
  - 親のフィールドに子のオブジェクトのコレクションを持つ場合(12.2.5)と、持たない場合(12.2.3, 12.2.4)がある。
  - いずれの場合も、子のオブジェクト側でマッピングを実施する
class Album {
  private Artist artist;
}

- 依存マッピング
  - 親のフィールドに子のオブジェクトをコレクションで保持するという構成。
  -  親のオブジェクト側で子のオブジェクトも一緒にマッピングを実施する
  - 子のオブジェクトが一つの親だけに参照される場合のみ適用可能。

### 多対多の場合
この場合、関連テーブルマッピングでしか選択肢がない。
1対多では外部キーマッピングより関連テーブルマッピングを選ぶメリットがない
- 関連テーブルマッピング
-   

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyNDgxMTM0NDAsMTE1NjU2NjEzLC0xOT
AwMDY3Mzg2XX0=
-->